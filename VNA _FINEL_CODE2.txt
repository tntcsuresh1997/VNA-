# System and utilities
import os
import time
import datetime
# GUI-related imports
import customtkinter as ctk
from customtkinter import filedialog
from ctk_scrollable_dropdown import CTkScrollableDropdown
from CTkMessagebox import CTkMessagebox
# Instrument control
import pyvisa
# Image handling
from PIL import Image
# Excel manipulation
import openpyxl
from openpyxl import Workbook, load_workbook
from openpyxl.styles import Font, PatternFill, Alignment, Border, Side
########################################################################################################################################################################
class VNA_DisplaySetting():
    def __init__(self):
        self.root = ctk.CTk() 
        ctk.set_appearance_mode("light")
        self.root.title("AAVIZA ELECTRONICS PRIVATE LIMITED")
        self.root.geometry("720x680")
        self.root.maxsize(1400,1000)
      # Initialize attributes
        self.read_model_id = []
        self.po_value = None
        self.count_value = None
        # UI Components
        self.label_markers = []
        self.entry_frequencies = []
        self.label_voltages = []
        self.entry_voltages = []
        # Data Storage
        self.list_option = []
        self.save_data1 = []
        self.parameter_setting_save = set()
        self.dist = {} 
        self.voltOutput = []
        self.list_freq = []
        self.list_volt = []
        self.list_sign = []
        self.list_po = []
        self.list_count = []
        self.valid_frequencies = []
        self.valid_voltages = []
        self.volt_add = []
        # Filepath and Selection
        self.filepath_csv = ""
        self.selectedValue = ''
        # Entry and State Management
        self.entry_count_1 = ''
        self.state = 0
        self.max_row = 0
        self.sample = []
        self.ports = []
        self.remaining_count = 10
        self.temp_dist_po_count = {}
        self.count = 0
        # Flags
        self.list_port_bool = True
        self.Txt_select_bool = False
        self.status_save = True
################################################## MODEL ID######################################################################################3
        self.path = 'D:\\VNA_MODEL_V2\\Aaviza_Utility\\logo4.png'
        self.update_image()
        icon_path = os.path.join(os.path.dirname(__file__),'D:\\VNA_MODEL_V2\\Aaviza_Utility\\logo1.ico')
        if os.path.exists(icon_path):
            self.root.iconbitmap(icon_path)
        self.get_model = ctk.CTkButton(self.root, text="Model_Num_Id  :", width=100, height=10,font=("Times New Roman", 18, "bold"), fg_color="#DB4035")
        self.get_model.place(x=10, y=150)
        self.get_model_ok = ctk.CTkButton(self.root, text="OK", width=10, height=10,font=("Times New Roman", 18, "bold"), fg_color="#DB4035",command=self.updatedModelId)
        self.get_model_ok.place(x=330, y=150)
        self.get_pono = ctk.CTkButton(self.root, text="PONO", width=100, height=10,font=("Times New Roman", 18, "bold"), fg_color="#4073FF")
        self.get_pono.place(x=400, y=50)
        self.get_entry = ctk.CTkButton(self.root, text="ENCT", width=100, height=10,font=("Times New Roman", 18, "bold"), fg_color="#4073FF")
        self.get_entry.place(x=632, y=50)
        self.get_reming = ctk.CTkButton(self.root, text="RECT", width=100, height=10,font=("Times New Roman", 18, "bold"), fg_color="#4073FF")
        self.get_reming.place(x=865, y=50)
        self.get_pono_entry = ctk.CTkTextbox(self.root, width=130,height=25)
        self.get_pono_entry.place(x=501, y=50)
        self.get_entry_count = ctk.CTkTextbox (self.root, width=130, height=25)
        self.get_entry_count.place(x=733, y=50)
        self.get_reming_count =ctk.CTkTextbox (self.root, width=130, height=25)
        self.get_reming_count.place(x=967, y=50)

        self.initialModleIdLoad()
  
        self.get_model_number_var = ctk.StringVar(value="Model ID")
        self.get_model_number = ctk.CTkComboBox(self.root, values = self.read_model_id, variable = self.get_model_number_var)
        self.get_model_number.place(x=170, y=150)
        self.drpodowScroll = CTkScrollableDropdown(self.get_model_number,values=self.read_model_id,justify="left",button_color="transparent",hover_color="Grey")
        self.channel_port= ctk.CTkButton(self.root, text=" Channel_Port     ", width=20, height=30,font=("Times New Roman", 18, "bold"),fg_color="#4073FF")
        self.channel_port.place(x=10, y=110)
        self.channel_port_var = ctk.StringVar(value="selecte")
        self.channel_port = ctk.CTkComboBox(self.root,values=["1","2","1,2"],variable=self.channel_port_var)
        self.channel_port.set("1")
        self.channel_port.place(x=170, y=110)
        self.textbox_port1 = ctk.CTkTextbox(self.root, width=450, height=580, font=("Times New Roman", 14))
        self.textbox_port2= ctk.CTkTextbox(self.root, width=450, height=580, font=("Times New Roman", 14))
        # Initial placement but hidden
        self.textbox_port1.place(x=390, y=100)
        self.textbox_port2.place(x=850, y=100)
        self.textbox_port1.place_forget()
        self.textbox_port2.place_forget()
        self.connect_button = ctk.CTkButton(self.root, text=" CONNECT   ", width=200, height=30,font=("Times New Roman", 18, "bold"),fg_color="#4073FF",command=self.open_textbox)
        self.connect_button.place(x=100, y=260)
        self.start_button = ctk.CTkButton(self.root, text=" START ", width=200, height=30,font=("Times New Roman", 18, "bold"),fg_color="#4073FF",command=self.Option_Menu)
        self.start_button.place(x=100, y=310)
        self.stop_button = ctk.CTkButton(self.root, text=" DISCONNECT ", width=200, height=30,font=("Times New Roman", 18, "bold"),fg_color="#4073FF",command=self.disconnect)
        self.stop_button.place(x=100, y=360)
        self.root.mainloop()

    def open_textbox(self):
        selected = self.channel_port_var.get().split(",")
        self.textbox_port1.place_forget()
        self.textbox_port2.place_forget()
       
        if "1" in selected:
            self.textbox_port1.place(x=390, y=100)
        else:
            self.textbox_port1.place_forget()
        
        if "2" in selected:
            self.textbox_port2.place(x=850, y=100)
        else:
            self.textbox_port2.place_forget()
        
        self.py_visa()

    def py_visa(self):
        self.connect_button.configure(state=ctk.DISABLED)
        try:
            VNA_IP = "127.0.0.1"  # IP address of the VNA
            PORT = 5001  # Communication port
            self.rm = pyvisa.ResourceManager()  # Initialize PyVISA Resource Manager
            resource_string = f"TCPIP::{VNA_IP}::{PORT}::SOCKET"
            self.MS46122B = self.rm.open_resource(resource_string)
            vna_id = self.MS46122B.query("*IDN?")
            #self.MS46122B.write('*RST\n')
            #time.sleep(1) 
            self.textbox_port1.insert(ctk.END, f"Connected to: {resource_string}\n")
            self.textbox_port1.insert(ctk.END, f"VNA Identity: {vna_id}\n")
            self.textbox_port2.insert(ctk.END, f"Connected to: {resource_string}\n")
            self.textbox_port2.insert(ctk.END, f"VNA Identity: {vna_id}\n")
            self.selected_port = self.channel_port.get().strip().upper()
        except pyvisa.VisaIOError as visa_error:
            self.msg=CTkMessagebox(title="Error", message="SHOCK LINE ANRITSU APP NOT OPEN ", option_1="OK")
            if self.msg.get()=="OK":
                self.connect_button.configure(state=ctk.NORMAL)

    def get_file_names(self,directory):
        """Retrieve all file names from a directory and store them in a list."""
        list_return=[]
        if not os.path.exists(directory):
           return []
        file_list = [file for file in os.listdir(directory) if os.path.isfile(os.path.join(directory, file))]
        for x in file_list:
            list_return.append(x.replace('.txt',''))
        return list_return
        
    def initialModleIdLoad(self):
        directory_path = f"D:\\VNA_MODEL_V2\\datasave\\Model_Settings"
        self.read_model_id = self.get_file_names(directory_path)
      
######################################################## Funtions ###################################################################################################################
    def update_image(self):
        self.my_image = ctk.CTkImage(light_image=Image.open(self.path), size=(380, 100))
        self.image_label = ctk.CTkLabel(self.root, image=self.my_image, text="")
        self.image_label.place(x=5, y=5)

    def change_logo_action(self):
        self.my_image = ctk.CTkImage(light_image=Image.open(self.path), size=(380, 100))
        self.image_label = ctk.CTkLabel(self.root, image=self.my_image, text="")
        self.image_label.place(x=5, y=5)
        
    def updatedModelId(self):
        self.moudel_var=self.get_model_number_var.get()
        filename = f"{self.moudel_var}.txt"
        directory = f"D:\\VNA_MODEL_V2\\datasave\\Model_Settings"
        full_path = os.path.join(directory, filename)
        filenamepo = f"{self.moudel_var}.txt"
        directorypo ="D:\\VNA_MODEL_V2\\datasave\\Model_PO_NO"
        filepath = os.path.join(directorypo, filenamepo)
        self.moudel_var=self.get_model_number.get()
        self.read_model_id.append(self.moudel_var)
        self.read_model_id = list(dict.fromkeys(self.read_model_id))
        if self.moudel_var not in self.read_model_id:
            self.read_model_id.append(self.moudel_var)
        else:
           pass

        self.drpodowScroll.configure(values=self.read_model_id,hover_color="Red")
        
        if os.path.exists(full_path):
            overwrite_choice = CTkMessagebox(
                    title="Info",
                    message=f"Model file already exists. Do you want to overwrite it?",
                    option_1="No",
                    option_2="Yes",
                ).get()
            if overwrite_choice == "Yes":
                self.open_parameter_setting()
            elif overwrite_choice == "No":
                self.readPoValues(filepath)
            self.Option_Menu()

        else:
            self .list_option.append(self.moudel_var)
            self.show_messagebox()

    def readPoValues(self,filepath):
        self.temp_dist_po_count={}
        self.list_po.clear()
        self.list_count.clear() 
        with open(filepath, 'r') as file:
            data = file.read().split("*")  
        for entry in data:
            entry = entry.strip()  
            xlist = entry.split(',')  
            for i in xlist:
                i = i.strip() 
                if i.startswith("_po_number"): 
                    po_value = i.split(":")[1]
                    self.list_po.append(po_value.strip())  
                elif i.startswith("Entry Count"):  
                    count_value = i.split(":")[1]
                    self.list_count.append(count_value.strip())  
        for i in range (len(self.list_count)):
            self.temp_dist_po_count[f"{self.list_po[i]}"] = self.list_count[i]
        
    def show_messagebox(self):
        self.get_model_ok.configure(state=ctk.DISABLED)
        self.get_model_number.configure(state=ctk.DISABLED)
        filenamepo = f"{self.moudel_var}.txt"
        directorypo ="D:\\VNA_MODEL_V2\\datasave\\Model_PO_NO"
        filepath = os.path.join(directorypo, filenamepo)
        
        try:
            self.msg=CTkMessagebox(title="AAVIZA ELECTRONICS PRIVATE LIMITED",message= "Parameter setting ",option_1="Yes",option_2="No")
        
            if self.msg.get() == 'Yes':
                
                self.open_parameter_setting()
               
            elif self.msg.get() == 'No':
                self.get_model_ok.configure(state=ctk.NORMAL)
                self.get_model_number.configure(state=ctk.NORMAL)
            else:
                self.get_model_ok.configure(state=ctk.NORMAL)
                self.get_model_number.configure(state=ctk.NORMAL)

        except Exception as e:
            pass

    def open_parameter_setting(self):
        self.open_root = ctk.CTkToplevel(self.root)
        self.open_root.geometry("720x680")
        self.open_root.maxsize(500, 600)
        self.open_root.title("AAVIZA ELECTRONICS PRIVATE LIMITED")
        self.get_marker = ctk.CTkButton(self.open_root, text="MARKER ID :", width=100, height=10,font=("Times New Roman", 18, "bold"), fg_color="#DB4035")
        self.get_marker.place(x=10, y=10)
        self.get_marker_ok = ctk.CTkButton(self.open_root, text="OK", width=10, height=10,font=("Times New Roman", 18, "bold"), fg_color="#DB4035",command=self.marker_setting)
        self.get_marker_ok.place(x=250, y=10)
        self.marker_entry = ctk.CTkEntry(self.open_root, width=70, placeholder_text="Marker ID")
        self.marker_entry.place(x=150, y=10)
        self.marker_entry.bind("<Return>", lambda event: self.get_marker_ok.invoke())
        self.open_root.mainloop()

    def marker_setting(self):
        try:
            self.get_marker_ok.configure(state=ctk.DISABLED)
            marker_count = int(self.marker_entry.get())

            if marker_count < 8:
                for i in range(marker_count):
                    self.label_marker = ctk.CTkLabel(self.open_root, text=f"Marker {i + 1}:", font=("Arial", 16))
                    self.label_marker.place(x=20, y=100 + i * 40)
                    self.label_markers.append(self.label_marker)
                    self.entry_frequency = ctk.CTkEntry(self.open_root, placeholder_text=f"{i + 1}.E06", width=80)
                    self.entry_frequency.place(x=100, y=100 + i * 40)
                    self.entry_frequency.bind("<Return>", lambda event, idx=i: self.focus_next_entry(idx, self.entry_frequencies, self.entry_voltages))
                    self.entry_frequencies.append(self.entry_frequency)
                    self.label_voltage = ctk.CTkLabel(self.open_root, text=f"Voltage {i + 1}:", font=("Arial", 16))
                    self.label_voltage.place(x=250, y=100 + i * 40)
                    self.label_voltages.append(self.label_voltage)
                    self.entry_voltage = ctk.CTkEntry(self.open_root, placeholder_text=f"<,0.00{i + 1}", width=80)
                    self.entry_voltage.place(x=350, y=100 + i * 40)
                    self.entry_voltage.bind("<Return>", lambda event, idx=+i: self.focus_next_entry(idx, self.entry_voltages, self.entry_frequencies))
                    self.entry_voltages.append(self.entry_voltage)
                self.save_button = ctk.CTkButton(self.open_root, text="Save", command=self.open_parameter_setting_save_data)
                self.save_button.place(x=250, y=150 + marker_count * 40 + 20)
                self.save_button.bind("<Return>", lambda event: self.save_button.invoke())
                self.clear_data = ctk.CTkButton(self.open_root, text="Clear", command=self.clear_marker)
                self.clear_data.place(x=10, y=150 + marker_count * 40 + 20)

            else:
                self.msg = CTkMessagebox(title="Info", message="Marker ID is out of bounds. Please enter a value less than 8.", option_1="OK")
                self.get_marker_ok.configure(state=ctk.NORMAL)

        except ValueError:
            self.msg = CTkMessagebox(title="Error", message="Please enter a valid integer for the Marker ID.", option_1="OK")
            self.get_marker_ok.configure(state=ctk.NORMAL)

    def focus_previous_entry(self, idx, entry_list):
        """Focus on the previous entry in the list."""
        if idx > 0:
            entry_list[idx - 1].focus()

    def focus_next_entry(self, idx, current_list, next_list):
        """Focus on the next entry in the list."""
        if idx < len(current_list) - 1:
            current_list[idx + 1].focus()
        elif current_list == self.entry_frequencies and len(next_list) < idx:
            next_list[idx].focus()  # Move to corresponding voltage entry
        elif current_list == self.entry_voltages and len(next_list) < idx:
            next_list[idx].focus()  # Move to next voltage entry

    def clear_marker(self):
        try:
            self.get_marker_ok.configure(state=ctk.NORMAL)
            
            for label in  self.label_markers:
                label.destroy()
            for entry in self.entry_frequencies:
                entry.destroy()
            for label in self.label_voltages:
                label.destroy()
            for entry in self.entry_voltages:
                entry.destroy()
            # Clear the list 
            self.label_markers.clear()
            self.entry_frequencies.clear()
            self.label_voltages.clear()
            self.entry_voltages.clear()
            self.save_button.destroy()
            self.clear_data.destroy()
        except:
            pass

    def open_parameter_setting_save_data(self):
        for i in range(len(self.label_markers)):
            label_marker_text = self.label_markers[i].cget("text")
            entry_frequency_value = self.entry_frequencies[i].get().strip()
            entry_voltage_value = self.entry_voltages[i].get().strip()
            self.dist[label_marker_text] = {
                "frequency": entry_frequency_value,
                "voltage": entry_voltage_value
            }
        if not any(self.entry_frequencies[i].get().strip() for i in range(len(self.entry_frequencies))) or \
                not any(self.entry_voltages[i].get().strip() for i in range(len(self.entry_voltages))):
            CTkMessagebox(title="Error", message="Please enter data", option_1="OK")
            return

        for i in range(len(self.entry_frequencies)):
            freq = self.entry_frequencies[i].get().strip()
            vol = self.entry_voltages[i].get().strip()
            if not freq:
                CTkMessagebox(title="Error", message="Please enter valid frequencies for all fields.", option_1="OK")
                return
            if not vol:
                CTkMessagebox(title="Error", message="Please enter valid voltages for all fields.", option_1="OK")
                return
            if freq.endswith(".E07"):
                CTkMessagebox(title="Error", message="Invalid frequency detected: '.E07' is not allowed.", option_1="OK")
                return
            if self.check(vol):
                CTkMessagebox(title="Error", message=f"Invalid voltage '{vol}'. Voltage must be exactly 6 characters.", option_1="OK")
                return
            self.valid_frequencies.append(freq)
            self.valid_voltages.append(vol)
        self.get_model_ok.configure(state=ctk.NORMAL)
        self.get_model_number.configure(state=ctk.NORMAL)
        self.parameter_setting_create_file(0)
        self.clear_marker()
        self.open_root.destroy()

    def check(self, voltage):
        length = len(voltage)
        if length < 6:
           return True  # Invalid voltage
        if (voltage.startswith("<,") or voltage.startswith(">,") ) and length == 6:
            self.valid_voltages.append(voltage)
            return False  # Valid voltage
        return True  # Invalid voltage

    def parameter_setting_create_file(self,read_Wreite):
        self.parameter_setting_save =self.get_model_number.get()
        filename=f"{self.parameter_setting_save}.txt"
        directory = f"D:\\VNA_MODEL_V2\\datasave\\Model_Settings"
        os.makedirs(os.path.dirname(directory), exist_ok=True)
        full_path = os.path.join(directory, filename)
        # Write data to the file
        if read_Wreite==0:
           with open(full_path, 'w') as file:
                for key_1, item_1 in self.dist.items():
                    file.write(f"{key_1} ")
                    for key_2, item_2 in item_1.items():
                        file.write(f"{key_2}:{item_2} ")
                    file.write("*\n")  # Add a newline for better readabilit
        # Read and process data from the file
        if read_Wreite==1:
            self.list_freq =[]
            volt_value=[]
            self.list_volt=[]
            volt_sign=[]
            self.list_sign=[]
            with open(full_path, 'r') as file:
                data = file.read().split("*")  # Split entries by '*'
                for entry in data:
                    entry = entry.strip()  # Remove extra spaces or newlines
                    if entry:  # Skip empty entries
                        parts = entry.split()  # Split the line into parts
                        for part in parts:
                            if part.startswith("frequency:"):
                                freq_value = part.split(":")[1]
                                self.list_freq.append(freq_value.strip())  # Add frequency value to list
                            elif part.startswith("voltage:"):
                                volt_sign1 = part.split(":")[1]
                                volt_sign = volt_sign1.split(',')[0].strip()
                                self.list_sign.append(volt_sign)
                                volt_value = volt_sign1.split(',')[1].strip()
                                self.list_volt.append(round(float(volt_value), 2))
                                self.volt_add.append(volt_sign1)  # Add original voltage value to list
                self.volt_add = [item.replace(",", "").strip() for item in self.volt_add]
 
    def dataRequesting(self,pass_count,pass_fail_list_1,pass_fail_list_2):
        for port in self.ports:
            self.MS46122B.write(f':CALC1:PAR{port}:DEF S1{port}')
            self.MS46122B.write(f":CALC1:PAR{port}:FORM SWR")

            for i, freq in enumerate(self.list_freq, start=1):
                self.MS46122B.write(f":CALC1:PAR{port}:MARK{i + 1}:X {freq}")
                time.sleep(0.1)
                self.voltoutput = self.MS46122B.query(f":CALC1:PAR{port}:MARK{i + 1}:Y?")
                try:
                    volt = round(float(self.voltoutput.strip()), 2)
                except ValueError:
                    continue

                if port == 1:
                    self.voltOutput_port1.append(volt)
                elif port == 2:
                    self.voltOutput_port2.append(volt)

            self.MS46122B.write(f":CALC1:PAR{port}:DEF USR,A{port},B{port},PORT{port}")

        # Evaluate pass/fail for all measurements
        for port in self.ports:
            if port == 1:
                for j, k in enumerate(self.list_sign):
                    if k == '<':
                        if self.voltOutput_port1[j] < self.list_volt[j]:
                            pass_count[0] += 1
                            pass_fail_list_1.append("PASS")
                        else:
                            
                            pass_fail_list_1.append("FAIL")
                    elif k == '>':
                        if self.voltOutput_port1[j] > self.list_volt[j]:
                            pass_count[0] += 1
                            pass_fail_list_1.append("PASS")
                        else:
                            
                            pass_fail_list_1.append("FAIL")
            if port == 2:
                for j, k in enumerate(self.list_sign):
                    if k == '<':
                        if self.voltOutput_port2[j] < self.list_volt[j]:
                            pass_count[1] += 1
                            pass_fail_list_2.append("PASS")
                        else:
                            
                            pass_fail_list_2.append("FAIL")
                    elif k == '>':
                        if self.voltOutput_port2[j] > self.list_volt[j]:
                            pass_count[1] += 1
                            pass_fail_list_2.append("PASS")
                        else:
                            
                            pass_fail_list_2.append("FAIL")

        return pass_count, pass_fail_list_1, pass_fail_list_2

    def start_buttons(self):
        

        pass_count = [0, 0]
        pass_fail_list_1 = []
        pass_fail_list_2 = []
        setStart = True
        countChek = False
        self.voltOutput_port1 = []
        self.voltOutput_port2 = []

        # Get selected ports and validate
        selected_ports = self.channel_port.get().strip()
        self.ports = []

        for port in selected_ports.split(','):
            if port.strip() == "1":
                self.ports.append(1)
            elif port.strip() == "2":
                self.ports.append(2)

        if not self.ports:
            CTkMessagebox(title="Invalid Port Selection", message="Please select valid port(s) (1 or 2)", icon="error").wait_window()
            return

        try:
            while setStart and self.list_port_bool:  # Replace recursion with a loop

                
                if self.DataRequestCheck:
                    pass_count = [0, 0]
                    pass_fail_list_1 = []
                    pass_fail_list_2 = []
                    date_time = datetime.datetime.now()
                    self.save_time = date_time.strftime("%H:%M:%S")
                    self.parameter_setting_create_file(1)
                    self.DataRequestCheck = False
                    pass_count, pass_fail_list_1, pass_fail_list_2 = self.dataRequesting(pass_count,pass_fail_list_1,pass_fail_list_2)

                # Determine which textbox to update based on port number
                for x, port in enumerate(self.ports): 
                    textbox_to_use = self.textbox_port1 if port == 1 else self.textbox_port2

                    if pass_count[port - 1] == len(self.list_sign):
                        for i in range(len(self.list_sign)):
                            if port == 1:
                                message = f"MARKER:  {i}  FREQ:  {self.list_freq[i]}  VOLT:  {self.voltOutput_port1[i]}  {pass_fail_list_1[i]}   {self.save_time} \n"
                            else:
                                message = f"MARKER:  {i}  FREQ:  {self.list_freq[i]}  VOLT:  {self.voltOutput_port2[i]}  {pass_fail_list_2[i]}   {self.save_time} \n"
                            textbox_to_use.insert(ctk.END, message)

                        self.msg = CTkMessagebox(title="Test Result", icon="check", message="PASS", option_1="Save & Continue Test", option_2="Close")
                        if self.msg.get() == "Save & Continue Test":
                            countChek = True
                            self.DataRequestCheck = True
                        else:
                            setStart = False
                    else:
                        for i in range(len(self.list_sign)):
                            if port == 1:
                                message = f"MARKER:  {i}  FREQ:  {self.list_freq[i]}  VOLT:  {self.voltOutput_port1[i]}  {pass_fail_list_1[i]}   {self.save_time} \n"
                            else:
                                message = f"MARKER:  {i}  FREQ:  {self.list_freq[i]}  VOLT:  {self.voltOutput_port2[i]}  {pass_fail_list_2[i]}   {self.save_time} \n"
                            textbox_to_use.insert(ctk.END, message)

                        self.msg = CTkMessagebox(title="Test Result", icon="cancel", message="FAIL", option_1="Continue Test", option_2="Close")
                        if self.msg.get() == "Continue Test":
                            countChek = False
                            self.DataRequestCheck = True
                        else:
                            self.DataRequestCheck = False
                            setStart = False

                if countChek:
                    print("countChek pass")
                    self.save_CSV('PASS')

                self.reset_test_data()

        except Exception as e:
            print(f".......Error: {e}")

    def reset_test_data(self):
        self.list_freq = []
        self.voltOutput_port1 = []
        self.voltOutput_port2 = []
        self.list_sign = []
        self.list_volt = []
        if self.textbox_port1:
            self.textbox_port1.delete('0.0', 'end')
        if self.textbox_port2:
            self.textbox_port2.delete('0.0', 'end')
        
    def disconnect(self):
        
        try:
            if self.MS46122B:
                self.MS46122B.write('*RST\n')
            self.MS46122B.close()
            self.rm.close()

        except Exception as e:
            pass
        time.sleep(0.1)
        self.list_po.clear()
        self.list_count.clear()

        try:
            if self.get_pono_entry:
                self.get_pono_entry.delete('0.0', 'end')
            if self.get_entry_count:
                self.get_entry_count.delete('0.0', 'end')
            if self.get_reming_count:
                self.get_reming_count.delete('0.0', 'end')
            if self.textbox_port1:
                self.textbox_port1.delete('0.0', 'end')
            if self.textbox_port2:
                self.textbox_port2.delete('0.0', 'end')
        except AttributeError as e:
            pass
      
    def Option_Menu(self):
        self.Optionmenu_root = ctk.CTkToplevel(self.root)
        self.Optionmenu_root.geometry("300x150")
        self.Optionmenu_root.title("AAVIZA ELECTRONICS PRIVATE LIMITED")
        self.optionmenu_var = ctk.StringVar()
        self.optionmenu = ctk.CTkOptionMenu(self.Optionmenu_root,values=self.read_model_id,command=self.Optionmenu_Callback,variable=self.optionmenu_var)
        self.optionmenu.pack(pady=20)
        self.voltOutput=[]
        self.Optionmenu_root.mainloop()

    def Optionmenu_Callback(self,choice):
        self.optionmenu.destroy()
        self.Optionmenu_root.destroy()
        self.enter_poid()
       
    def enter_poid(self):
        self.Txt_select_bool=True
        self.poid_root = ctk.CTkToplevel(self.root)
        self.poid_root.geometry("480x180")
        self.poid_root.resizable(False, False)
        self.poid_root.title("AAVIZA ELECTRONICS PRIVATE LIMITED")
        self.voltOutput=[]
        self.order_label = ctk.CTkLabel(self.poid_root, text="PO ID:", width=20, height=30,font=("Times New Roman", 18, "bold"))
        self.order_label.place(x=0, y=10)
        self.entry_count_label = ctk.CTkLabel(self.poid_root, text="PO COUNT:", width=20, height=30,font=("Times New Roman", 18, "bold"))
        self.entry_count_label.place(x=0, y=50)
        self.count_entry_1 = ctk.CTkEntry(self.poid_root, width=200,placeholder_text="Enter order ID")
        self.count_entry_1.place(x=100, y=10)
        self.count_entry_2 = ctk.CTkEntry(self.poid_root, width=200,placeholder_text="Enter Quantity")
        self.count_entry_2.place(x=100, y=50)
        self.submit_button = ctk.CTkButton(self.poid_root, text="Save",command=lambda:[self.count_check_int(),self.show_values(), self.po_save_data()])
        self.submit_button.place(x=310, y=20)
        self.PO_combo_var = ctk.StringVar(value="Select")
        self.PO_combo = ctk.CTkComboBox(self.poid_root, values=self.list_po,command=self.ok_button,variable=self.PO_combo_var)
        self.PO_combo.set("Select an option")
        self.PO_combo.place(x=20, y=110)
        self.poid_root.mainloop()

    def ok_button(self, selected_value):
        self.selectedValue = selected_value
        self.state = 0
        self.entry_count_1 =" "
        if self.selectedValue.strip() != "Select an option":
            try:
                self.get_pono_entry.delete('0.0', 'end')
                self.get_pono_entry.insert(ctk.END, self.selectedValue)
                self.Txt_select_bool=False
                self.get_entry_count.delete('0.0', 'end')
                self.get_entry_count.insert(ctk.END, self.temp_dist_po_count[f"{self.selectedValue}"])
            except Exception as e:
               pass
            self.poid_root.destroy()
            self.start_buttons()  
    
    def show_values(self): 
        if self.status_save:
            self.get_modelvalue= self.get_model_number.get()
            self.entry_count_1 = self.count_entry_1.get()
            self.state = 1
            self.entry_count_2 = self.count_entry_2.get() 
            self.save_data1 = {
                "order_id": self.get_modelvalue,
                "entry_count": self.entry_count_1,
                "Entry Count 2":self.entry_count_2
            }
            self.poid_root.destroy()

    def count_check_int(self):
        self.quantity_count = self.count_entry_2.get().strip()  
        if not self.quantity_count.isnumeric(): 
            self.msg=CTkMessagebox(title="Notice",message="Check number count; it should be an integer (e.g., 100).",option_1="OK")
            if self.msg.get()=="OK":
                self.status_save=False
                self.msg.destroy()
        else:
            self.status_save=True
            
    def po_save_data(self):
        try:
            # Initialize lists for storing header values
            list_volt_csv = []
            list_Freq_csv = []
            model_list = []

            # Ensure saving is allowed
            if self.status_save:
                # Define file and directory paths
                filename_po_no = f"{self.get_modelvalue}.txt"
                directory_po_no = "D:\\VNA_MODEL_V2\\datasave\\Model_PO_NO"
                os.makedirs(directory_po_no, exist_ok=True)
                filepath_po = os.path.join(directory_po_no, filename_po_no)

                directory_csv = f"D:\\VNA_MODEL_V2\\MODELS\\{self.get_modelvalue}"
                filename_csv = f"{self.entry_count_1}.xlsx"
                os.makedirs(directory_csv, exist_ok=True)
                self.filepath_csv = os.path.join(directory_csv, filename_csv)

                if os.path.isdir(directory_csv):
                    # Create parameter setting file
                    self.parameter_setting_create_file(1)

                    # Prepare headers for the Excel sheet
                    model_list.append(f"{self.get_modelvalue} TESTING RESULT DATA")
                    list_Freq_csv.append("Test Freq.(MHz)")
                    list_volt_csv.append("VSWR")
                    list_Freq_csv.extend(self.list_freq)
                    list_volt_csv.extend(self.volt_add)
                    list_Freq_csv.extend(["RESULT", "Timestamp"])
                    list_volt_csv.extend([" ", " "])

                    # Create and initialize the Excel file
                    wb = Workbook()
                    ws = wb.active

                    # Apply styles to the header row
                    border = Border(left=Side(border_style="thick"),right=Side(border_style="thick"),top=Side(border_style="thick"),bottom=Side(border_style="thick"))
                    bold_font_large = Font(bold=True, size=15)
                    blue_fill = PatternFill(start_color='97E7F5', end_color='97E7F5', fill_type='solid')
                    yellow_fill = PatternFill(start_color='83F28F', end_color='83F28F', fill_type='solid')

                    # Merge and style the top header
                    ws.merge_cells("A1:H1")
                    header_cell = ws["A1"]
                    header_cell.value = model_list[0]
                    header_cell.alignment = Alignment(horizontal="center", vertical="center", wrap_text=True)
                    header_cell.font = bold_font_large
                    header_cell.fill = blue_fill
                    #header_cell.border = border

                    # Add additional rows with styles
                    for col, value in enumerate(list_Freq_csv, start=1):
                        cell = ws.cell(row=2, column=col, value=value)
                        cell.font = Font(bold=True)
                        cell.fill = yellow_fill
                        #cell.border = border 

                    for col, value in enumerate(list_volt_csv, start=1):
                        cell = ws.cell(row=3, column=col, value=value)
                        cell.font = Font(bold=True)
                        cell.fill = yellow_fill
                        #cell.border = border

                    # Adjust column widths
                    for col_index in range(1, ws.max_column + 1):
                        col_letter = chr(64 + col_index)
                        max_length = max(len(str(cell.value or "")) for cell in ws[col_letter])
                        ws.column_dimensions[col_letter].width = max_length + 2

                    # Save the workbook
                    wb.save(self.filepath_csv)

                    # Handle PO number and count entry
                    if self.entry_count_1 and self.entry_count_2:
                        with open(filepath_po, 'a') as file:
                            file.write(f"_po_number: {self.entry_count_1}, Entry Count: {self.entry_count_2}*\n")

                        self.readPoValues(filepath_po)

                        # Update UI elements
                        if self.list_po:
                            self.get_pono_entry.delete('0.0', 'end')
                            self.get_pono_entry.insert(ctk.END, self.entry_count_1)

                        if self.list_count:
                            self.get_entry_count.delete('0.0', 'end')
                            self.get_entry_count.insert(ctk.END, self.entry_count_2)

                        # Start button sequence
                        self.start_buttons()
                    else:
                        # Display a message if inputs are missing
                        CTkMessagebox(
                            title="AAVIZA ELECTRONICS PRIVATE LIMITED",
                            message="Enter New PO Number and Count Number",
                            option_1="Ok"
                        )
        except Exception as e:
            # Log the error or display a message box
            CTkMessagebox(
                title="Error",
                message=f"An error occurred: {e}",
                option_1="Ok"
            )

    def save_CSV(self,strValue):
        self.count += 1
        list_save_volt1 = []
        list_save_volt2 = []
        date_time = datetime.datetime.now()
        self.save_time = date_time.strftime("%H:%M:%S")

        # Directory and filename setup
        directory_csv = f"D:\\VNA_MODEL_V2\\MODELS\\{self.optionmenu_var.get()}"
        if os.path.isdir(directory_csv):  # Ensure the directory exists
            filename_csv = f'{self.entry_count_1}.xlsx' if self.state == 1 else f"{self.selectedValue}.xlsx"
        filepath_csv = os.path.join(directory_csv, filename_csv)

        # Load or create workbook
        if os.path.exists(filepath_csv):
            wb = load_workbook(filepath_csv)
            ws = wb.active
        else:
            wb = Workbook()
            ws = wb.active
            header = self.voltOutput_port1 + self.voltOutput_port2 + ['Result', 'Timestamp']
            ws.append(header)

        # Get the total count of filled rows
        self.listtotal_count = self.count_filled_rows(filepath_csv, "Sheet")

        # Generate sample labels based on the selected port
        if self.listtotal_count > 0:
            sample_label1 = f"sample{self.listtotal_count}"
            sample_label2 = f"sample{self.listtotal_count + 1}"
            if self.channel_port.get().strip() == "1,2":
                list_save_volt1.append(sample_label1)
                list_save_volt2.append(sample_label2)
            elif self.channel_port.get().strip() == "1":
                list_save_volt1.append(sample_label1)
            else:
                list_save_volt2.append(sample_label2)

        # Handle case where remaining count and port configuration conflict
        try:
            if self.channel_port.get().strip() == "1,2" and self.remaining_count <= 5 and self.count == 1:
                print("******b", self.remaining_count)
                self.msg = CTkMessagebox(
                    title="AAVIZA ELECTRONICS PRIVATE LIMITED",
                    message="Please connect to a single port (1 or 2).",
                    option_1="Ok"
                )
                self.list_port_bool = False
                if self.msg.get() == "Ok":
                    self.list_port_bool = True
            else:
                print("******a", self.remaining_count)
                self.count = 0
                # Append data for each selected port
                for port in self.ports:
                    if port == 1:
                        list_save_volt1.extend(self.voltOutput_port1)
                        list_save_volt1.append(strValue)
                        list_save_volt1.append(self.save_time)  # Timestamp
                        ws.append(list_save_volt1)
                    elif port == 2:
                        list_save_volt2.extend(self.voltOutput_port2)
                        list_save_volt2.append(strValue)
                        list_save_volt2.append(self.save_time)  # Timestamp
                        ws.append(list_save_volt2)
                    else:  # Fallback case for unhandled port configurations
                        list_save_volt1.extend(self.voltOutput_port1)
                        list_save_volt1.append(strValue)
                        list_save_volt1.append(self.save_time)  # Timestamp
                        ws.append(list_save_volt1)
                        list_save_volt2.extend(self.voltOutput_port2)
                        list_save_volt2.append(strValue)
                        list_save_volt2.append(self.save_time)  # Timestamp
                        ws.append(list_save_volt2)
      

            # Save workbook and execute additional operations
            wb.save(filepath_csv)
            time.sleep(0.1)
            self.run_example(filepath_csv)
        except Exception as e:
            print("An error occurred:", e)

    def count_filled_rows(self, file_path, sheet_name):
       
        if not os.path.exists(file_path):
            return 0

        try:
            # Load the workbook
            workbook = openpyxl.load_workbook(file_path, read_only=True)
            
            # Check if the sheet exists
            if sheet_name not in workbook.sheetnames:
                workbook.close()
                return 0

            # Access the sheet
            sheet = workbook[sheet_name]
            
            # Count filled rows
            filled_row_count = sum(
                any(cell.value is not None for cell in row) for row in sheet.iter_rows()
            )

            workbook.close()
            return filled_row_count

        except Exception as e:
            print(f"Error counting filled rows: {e}")
            return 0
        
    def run_example(self, file_path):
       
        sheet_name = "Sheet"
        self.listtotal_count = self.count_filled_rows(file_path, sheet_name)

        # Determine the key based on the selection state
        key = f"{self.entry_count_1}" if self.Txt_select_bool else f"{self.selectedValue}"

        # Calculate the remaining count
        self.remaining_count = int(self.temp_dist_po_count.get(key, 0)) - self.listtotal_count+3
        self.sample.append(self.listtotal_count)

        # Update the remaining count in the UI
        if self.get_reming_count:
            self.get_reming_count.delete('0.0', 'end')  
            self.get_reming_count.insert(ctk.END, self.remaining_count)

        # Check if the test is completed
        if self.remaining_count == 0:
            self.msg = CTkMessagebox(
                title="AAVIZA ELECTRONICS PRIVATE LIMITED",
                message="Test is completed",
                option_1="Ok"
            )

            if self.msg.get() == "Ok":
                # Perform cleanup actions
                self.list_pono_remove()
                self.get_reming_count.delete('0.0', 'end')
                self.get_pono_entry.delete('0.0', 'end')
                self.get_entry_count.delete('0.0', 'end')
                self.textbox_port1.delete('0.0', 'end')
                self.textbox_port2.delete('0.0', 'end')
                self.disconnect()

    def list_pono_remove(self):
    
        # File path setup
        filenamePoNo = f"{self.optionmenu_var.get()}.txt"
        directoryPONO = "D:\\VNA_MODEL_V2\\datasave\\Model_PO_NO"
        os.makedirs(directoryPONO, exist_ok=True)
        filepath = os.path.join(directoryPONO, filenamePoNo)

        # Determine PO to remove
        pono_to_remove = self.entry_count_1.strip() if self.entry_count_1.strip() else self.selectedValue.strip()

        # Check if the PO exists in the list
        if pono_to_remove in [item.strip() for item in self.list_po]:
            # Remove the PO from the list
            previous_count = len(self.list_po)
            self.list_po = [item for item in self.list_po if item.strip() != pono_to_remove]
            removed_count = previous_count - len(self.list_po)

            try:
                # Update the PO file by removing the specified entry
                with open(filepath, 'r') as file:
                    lines = file.readlines()

                updated_lines = [line for line in lines if pono_to_remove not in line]

                with open(filepath, 'w') as file:
                    file.writelines(updated_lines)

            except IOError as e:
                # Handle file errors
                CTkMessagebox(
                    title="Error",
                    message=f"Could not update the file due to: {e}",
                    option_1="OK"
                )
        else:
            # Display a notice if PO is not found
            CTkMessagebox(
                title="Notice",
                message="PO not found or already removed.",
                option_1="OK"
            )

        # Update the UI
        self.PO_combo.configure(values=list(self.temp_dist_po_count.keys()))
        self.PO_combo_var.set("Select an option")  # Reset ComboBox to default state

if __name__=="__main__":
    try:
        comm_port= VNA_DisplaySetting()
        
    except:
        pass